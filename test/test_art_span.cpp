// Copyright 2025 UnoDB contributors

//
// CAUTION: [global.hpp] MUST BE THE FIRST INCLUDE IN ALL SOURCE AND
// HEADER FILES !!!
//
// This header defines _GLIBCXX_DEBUG and _GLIBCXX_DEBUG_PEDANTIC for
// DEBUG builds.  If some standard headers are included before and
// after those symbols are defined, then that results in different
// container internal structure layouts and that is Not Good.
#include "global.hpp"  // IWYU pragma: keep

// IWYU pragma: no_include <array>
// IWYU pragma: no_include <string>
// IWYU pragma: no_include "gtest/gtest.h"

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <limits>
#include <stdexcept>
#include <tuple>
#include <utility>
#include <vector>

#include <gtest/gtest.h>

#include "art.hpp"
#include "art_common.hpp"
#include "db_test_utils.hpp"
#include "gtest_utils.hpp"
#include "test_utils.hpp"
#include "thread_sync.hpp"

namespace unodb::test {

// Keys for testing variable length key support.  Note that it is NOT
// legal for one key to be a prefix of another key. This restriction
// is not on keys sharing a common prefix. That is legal and expected.
// It is on some complete key being a prefix of some other key. That
// is a contract violation.
//
// This contract violation can only arise with string data, because
// this is the only data whose length varys in the key (in all other
// cases a simple or compound key is always the same byte length for a
// given index).  The proper use of the key_encoder avoids this
// situation all compound keys and for simple keys whose sole
// component is some string data.
//
// Since the keys below are generated by hand, they need to explicitly
// avoid violating this contract.  For these test keys, we choose a
// specific length which is NOT a multiple of 8, e.g., a u16 + u8
// compound key.  The keys are also choosen such that there is always
// a key before or after any declared key.
//
// Note: One consequence of this choice of keys is that the tree is
// never more than two levels deep.  Since some keys have the same
// first byte, those keys could share a common prefix and exist as
// direct children of the root leaf.  However, other keys have a
// different first byte, which will force the split of the root inode
// and result in a tree with two inode levels and leaves.  This means
// that only limited test coverage can be obtained with this set of
// keys.
//
// FIXME More extensive test coverage is obtained using strings, which
// also lets us look for whether the code can encounter the key prefix
// contract violation when correctly using the key_encoder.  We can
// avoid using Unicode sort keys here for testing purposes, but a real
// database application would generate Unicode sort keys using a
// quality library and then use the key_encoder to build the keys.
//
// FIXME(thompsonbry) can an application meaningfully index arbitrary
// C strings or string_view objects?  I suspect NO to the latter
// unless we have an explicit code path for that which handles the
// truncation to maxlen for the key component and automatically
// handles the padding (pad byte plus run length) of the key out to
// maxlen.
//
// FIXME(thompsonbry) Change map => unordered_map since map order can
// not be used?  Or is lexicographic order maintained by the r/b map?
// Also, do we need that order in the verifier? Should the verifier
// handle scan checks?  Those are in their own test suites right now.
//
// FIXME(thompsonbry) Modify original benchmarks to automatically
// promote int keys to u64 or key_view depending on the database under
// test?  Less code. Then test_art_span will be specific to composite
// keys and C string and string_view keys.

constexpr auto test_key_0 =
    std::array<std::byte, 3>{std::byte{0x02}, std::byte{0x05}, std::byte{0x05}};
constexpr auto test_key_1 =
    std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x00}, std::byte{0x05}};
constexpr auto test_key_2 =
    std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x00}, std::byte{0x10}};
constexpr auto test_key_3 =
    std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x05}, std::byte{0x05}};
constexpr auto test_key_4 =
    std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x05}, std::byte{0x10}};
constexpr auto test_key_5 =
    std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x10}, std::byte{0x05}};
constexpr auto test_key_6 =
    std::array<std::byte, 3>{std::byte{0x04}, std::byte{0x05}, std::byte{0x10}};
constexpr auto test_key_7 =
    std::array<std::byte, 3>{std::byte{0x04}, std::byte{0x10}, std::byte{0x05}};

constexpr std::array<unodb::key_view, 8> test_keys = {
    unodb::key_view{test_key_0},  // [0] { 02 05 05 }
    unodb::key_view{test_key_1},  // [1] { 03 00 05 }
    unodb::key_view{test_key_2},  // [2] { 03 00 10 }
    unodb::key_view{test_key_3},  // [3] { 03 05 05 }
    unodb::key_view{test_key_4},  // [4] { 03 05 10 }
    unodb::key_view{test_key_5},  // [5] { 03 10 05 }
    unodb::key_view{test_key_6},  // [6] { 04 05 10 }
    unodb::key_view{test_key_7}   // [7] { 04 10 05 }
};
}  // namespace unodb::test

namespace {
using unodb::detail::thread_syncs;
using unodb::test::test_values;

template <class Db>
class ARTSpanCorrectnessTest : public ::testing::Test {
 public:
  using Test::Test;
};

using ARTTypes =
    ::testing::Types<unodb::test::key_view_db, unodb::test::key_view_mutex_db,
                     unodb::test::key_view_olc_db>;

UNODB_TYPED_TEST_SUITE(ARTSpanCorrectnessTest, ARTTypes)

template <typename DB>
void do_single_key_operations_on_empty_tree_test(unodb::key_view key,
                                                 unodb::value_view val) {
  DB db;
  // unodb::test::detail::assert_not_found<DB>(db.get(key));
  {
    uint64_t n = 0;
    auto fn = [&n](const unodb::visitor<typename DB::iterator>&) {
      n++;           // LCOV_EXCL_LINE
      return false;  // LCOV_EXCL_LINE
    };
    db.scan(fn);
    UNODB_EXPECT_EQ(0, n);
  }
  EXPECT_TRUE(db.insert(key, val));
  const auto tmp = db.get(key);
  unodb::test::detail::assert_value_eq<DB>(tmp, val);
  {
    uint64_t n = 0;
    std::vector<std::pair<unodb::key_view, unodb::value_view>> expected;
    expected.emplace_back(key, val);  // key is already encoded.
    auto fn =
        [&n, &expected](const unodb::visitor<typename DB::iterator>& visitor) {
          const auto& k = visitor.get_key();
          const auto& v = visitor.get_value();
          EXPECT_TRUE(std::ranges::equal(k, expected[n].first));
          EXPECT_TRUE(std::ranges::equal(v, expected[n].second));
          n++;           // LCOV_EXCL_LINE
          return false;  // LCOV_EXCL_LINE
        };
    db.scan(fn);
    UNODB_EXPECT_EQ(1, n);
  }
  EXPECT_TRUE(db.remove(key));
  unodb::test::detail::assert_not_found<DB>(db.get(key));
  EXPECT_FALSE(db.remove(key));
  {
    uint64_t n = 0;
    auto fn = [&n](const unodb::visitor<typename DB::iterator>&) {
      n++;           // LCOV_EXCL_LINE
      return false;  // LCOV_EXCL_LINE
    };
    db.scan(fn);
    UNODB_EXPECT_EQ(0, n);
  }
}

UNODB_START_TYPED_TESTS()

/// Unit test bootstraps variable length key support by testing the
/// full public API for a single key/value pair in an otherwise empty
/// tree.
TYPED_TEST(ARTSpanCorrectnessTest, DISABLED_SingleKeyOperationsOnEmptyTree) {
  const auto val = unodb::test::test_values[0];
  do_single_key_operations_on_empty_tree_test<TypeParam>(
      unodb::test::test_keys[0], val);
  do_single_key_operations_on_empty_tree_test<TypeParam>(
      unodb::test::test_keys[1], val);
  do_single_key_operations_on_empty_tree_test<TypeParam>(
      unodb::test::test_keys[2], val);
  do_single_key_operations_on_empty_tree_test<TypeParam>(
      unodb::test::test_keys[3], val);
  do_single_key_operations_on_empty_tree_test<TypeParam>(
      unodb::test::test_keys[4], val);
  do_single_key_operations_on_empty_tree_test<TypeParam>(
      unodb::test::test_keys[5], val);
  do_single_key_operations_on_empty_tree_test<TypeParam>(
      unodb::test::test_keys[6], val);
  do_single_key_operations_on_empty_tree_test<TypeParam>(
      unodb::test::test_keys[7], val);
}

/// Unit test of correct rejection of a key which is too large to be
/// stored in the tree.
UNODB_DETAIL_DISABLE_MSVC_WARNING(6326)
TYPED_TEST(ARTSpanCorrectnessTest, TooLongKey) {
  constexpr std::byte fake_val{0x00};
  const unodb::key_view too_long{
      &fake_val,
      static_cast<std::uint64_t>(std::numeric_limits<std::uint32_t>::max()) +
          1U};

  unodb::test::tree_verifier<TypeParam> verifier;

  UNODB_ASSERT_THROW(std::ignore = verifier.get_db().insert(too_long, {}),
                     std::length_error);

  verifier.assert_empty();

#ifdef UNODB_DETAIL_WITH_STATS
  verifier.assert_growing_inodes({0, 0, 0, 0});
#endif  // UNODB_DETAIL_WITH_STATS
}
UNODB_DETAIL_RESTORE_MSVC_WARNINGS()

/// Note: This UT examines a case where one encoded key is a prefix of
/// another encoded key, which is a contract violation.  The keys are
/// 00 and 00 02. The 00 key is inserted first.  The root inode has a
/// prefix of 00.  The 00 key ends at the root leaf.
///
/// FIXME(thompsonbry) Test in both insertion orders and do versions
/// of this test for each carefully constructed state of the tree
/// (different tree depths so we can check each structural
/// modification point at which this violation could be detected and
/// verify that we correctly detect the problem).  This might get
/// moved into its own test suite and if not, it should be moved into
/// its own section of this test suite.  It is good to look at this at
/// the same time as C string or string_view backed key_view keys.
#if 0
TYPED_TEST(ARTSpanCorrectnessTest, IllegalPrefixRejectLeafExpansionToI4) {
  unodb::test::tree_verifier<TypeParam> verifier;

  const auto& k0 = unodb::test::test_values[0];  // 00
  const auto& k1 = unodb::test::test_values[1];  // 00 02
  const auto& k2 = unodb::test::test_values[2];  // 03 00 01

  verifier.insert(k0, unodb::test::test_values[1]);
  verifier.get_db().dump();  // FIXME REMOVE

#ifdef UNODB_DETAIL_WITH_STATS
  verifier.assert_node_counts({1, 0, 0, 0, 0});
  verifier.assert_growing_inodes({0, 0, 0, 0});
#endif  // UNODB_DETAIL_WITH_STATS

  verifier.insert(k1, unodb::test::test_values[2]);
  verifier.get_db().dump();  // FIXME REMOVE

  verifier.check_present_values();  // FIXME FAILS HERE
  verifier.check_absent_keys({k2});

#ifdef UNODB_DETAIL_WITH_STATS
  verifier.assert_node_counts({2, 1, 0, 0, 0});
  verifier.assert_growing_inodes({1, 0, 0, 0});
#endif  // UNODB_DETAIL_WITH_STATS
}
#endif

UNODB_END_TESTS()

}  // namespace
