// Copyright 2025 UnoDB contributors

// Should be the first include
#include "global.hpp"  // IWYU pragma: keep

// IWYU pragma: no_include <array>
// IWYU pragma: no_include <string>
// IWYU pragma: no_include "gtest/gtest.h"

#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <limits>
#include <stdexcept>
#include <tuple>
#include <utility>
#include <vector>

#include <gtest/gtest.h>

#include "art.hpp"
#include "art_common.hpp"
#include "db_test_utils.hpp"
#include "gtest_utils.hpp"
#include "test_utils.hpp"
#include "thread_sync.hpp"

namespace unodb::test {

// FIXME(thompsonbry) reuse or remove.
//
// // Since the keys below are generated by hand, they need to explicitly
// // avoid violating this contract.  For these test keys, we choose a
// // specific length which is NOT a multiple of 8, e.g., a u16 + u8
// // compound key.  The keys are also choosen such that there is always
// // a key before or after any declared key.
// //
// // Note: One consequence of this choice of keys is that the tree is
// // never more than two levels deep.  Since some keys have the same
// // first byte, those keys could share a common prefix and exist as
// // direct children of the root leaf.  However, other keys have a
// // different first byte, which will force the split of the root inode
// // and result in a tree with two inode levels and leaves.  This means
// // that only limited test coverage can be obtained with this set of
// // keys.
//
// constexpr auto test_key_0 =
//     std::array<std::byte, 3>{std::byte{0x02}, std::byte{0x05},
//     std::byte{0x05}};
// constexpr auto test_key_1 =
//     std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x00},
//     std::byte{0x05}};
// constexpr auto test_key_2 =
//     std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x00},
//     std::byte{0x10}};
// constexpr auto test_key_3 =
//     std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x05},
//     std::byte{0x05}};
// constexpr auto test_key_4 =
//     std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x05},
//     std::byte{0x10}};
// constexpr auto test_key_5 =
//     std::array<std::byte, 3>{std::byte{0x03}, std::byte{0x10},
//     std::byte{0x05}};
// constexpr auto test_key_6 =
//     std::array<std::byte, 3>{std::byte{0x04}, std::byte{0x05},
//     std::byte{0x10}};
// constexpr auto test_key_7 =
//     std::array<std::byte, 3>{std::byte{0x04}, std::byte{0x10},
//     std::byte{0x05}};
//
// constexpr std::array<unodb::key_view, 8> test_keys = {
//     unodb::key_view{test_key_0},  // [0] { 02 05 05 }
//     unodb::key_view{test_key_1},  // [1] { 03 00 05 }
//     unodb::key_view{test_key_2},  // [2] { 03 00 10 }
//     unodb::key_view{test_key_3},  // [3] { 03 05 05 }
//     unodb::key_view{test_key_4},  // [4] { 03 05 10 }
//     unodb::key_view{test_key_5},  // [5] { 03 10 05 }
//     unodb::key_view{test_key_6},  // [6] { 04 05 10 }
//     unodb::key_view{test_key_7}   // [7] { 04 10 05 }
// };
}  // namespace unodb::test

namespace {
using unodb::detail::thread_syncs;
using unodb::test::test_values;

template <class Db>
class ARTKeyViewCorrectnessTest : public ::testing::Test {
 public:
  using Test::Test;
};

using ARTTypes =
    ::testing::Types<unodb::test::key_view_db, unodb::test::key_view_mutex_db,
                     unodb::test::key_view_olc_db>;

UNODB_TYPED_TEST_SUITE(ARTKeyViewCorrectnessTest, ARTTypes)

/// Unit test of correct rejection of a key which is too large to be
/// stored in the tree.
UNODB_DETAIL_DISABLE_MSVC_WARNING(6326)
TYPED_TEST(ARTKeyViewCorrectnessTest, TooLongKey) {
  constexpr std::byte fake_val{0x00};
  const unodb::key_view too_long{
      &fake_val,
      static_cast<std::uint64_t>(std::numeric_limits<std::uint32_t>::max()) +
          1U};

  unodb::test::tree_verifier<TypeParam> verifier;

  UNODB_ASSERT_THROW(std::ignore = verifier.get_db().insert(too_long, {}),
                     std::length_error);

  verifier.assert_empty();

#ifdef UNODB_DETAIL_WITH_STATS
  verifier.assert_growing_inodes({0, 0, 0, 0});
#endif  // UNODB_DETAIL_WITH_STATS
}
UNODB_DETAIL_RESTORE_MSVC_WARNINGS()

/// Unit test inserts several string keys with proper encoding and
/// validates the tree.
TYPED_TEST(ARTKeyViewCorrectnessTest, EncodedTextKeys) {
  unodb::test::tree_verifier<TypeParam> verifier;
  unodb::key_encoder enc;
  constexpr auto& val = unodb::test::test_values[0];
  verifier.insert(enc.reset().encode_text("").get_key_view(), val);
  verifier.insert(enc.reset().encode_text("a").get_key_view(), val);
  verifier.insert(enc.reset().encode_text("abba").get_key_view(), val);
  verifier.insert(enc.reset().encode_text("banana").get_key_view(), val);
  verifier.insert(enc.reset().encode_text("camel").get_key_view(), val);
  verifier.insert(enc.reset().encode_text("yellow").get_key_view(), val);
  verifier.insert(enc.reset().encode_text("ostritch").get_key_view(), val);
  verifier.insert(enc.reset().encode_text("zebra").get_key_view(), val);
  verifier.check_present_values();  // checks keys and key ordering.
}

/// Unit test inserts several string keys WITHOUT proper encoding
/// (they are just copied in by unodb::key_encoder::append_text(const
/// char*)) but which do not violate the contract (no key may be a
/// prefix of some other key) and validates the tree.
///
/// NOTE: For this test, we do not use any keys which are a prefix of
/// another key!!!  E.g., we use "abba" so we do not use "a" since
/// that is a prefix of "abba".  Likewise, we do not use "" since that
/// is a prefix of all other strings.
TYPED_TEST(ARTKeyViewCorrectnessTest, StringKeysWithoutProperEncoding) {
  unodb::test::tree_verifier<TypeParam> verifier;
  unodb::key_encoder enc;
  constexpr auto& val = unodb::test::test_values[0];
  verifier.insert(enc.reset().append("abba").get_key_view(), val);
  verifier.insert(enc.reset().append("banana").get_key_view(), val);
  verifier.insert(enc.reset().append("camel").get_key_view(), val);
  verifier.insert(enc.reset().append("yellow").get_key_view(), val);
  verifier.insert(enc.reset().append("ostritch").get_key_view(), val);
  verifier.insert(enc.reset().append("zebra").get_key_view(), val);
  verifier.check_present_values();  // checks keys and key ordering.
}

/// TODO(thompsonbry) multi-field keys tests

/// Note: This UT examines a case where one encoded key is a prefix of
/// another encoded key, which is a contract violation.  The keys are
/// 00 and 00 02. The 00 key is inserted first.  The root inode has a
/// prefix of 00.  The 00 key ends at the root leaf.
///
/// FIXME(thompsonbry) Test in both insertion orders and do versions
/// of this test for each carefully constructed state of the tree
/// (different tree depths so we can check each structural
/// modification point at which this violation could be detected and
/// verify that we correctly detect the problem).  This might get
/// moved into its own test suite and if not, it should be moved into
/// its own section of this test suite.  It is good to look at this at
/// the same time as C string or string_view backed key_view keys.
#if 0
TYPED_TEST(ARTKeyViewCorrectnessTest, IllegalPrefixRejectLeafExpansionToI4) {
  unodb::test::tree_verifier<TypeParam> verifier;

  const auto& k0 = unodb::test::test_values[0];  // 00
  const auto& k1 = unodb::test::test_values[1];  // 00 02
  const auto& k2 = unodb::test::test_values[2];  // 03 00 01

  verifier.insert(k0, unodb::test::test_values[1]);
  verifier.get_db().dump();  // FIXME REMOVE

#ifdef UNODB_DETAIL_WITH_STATS
  verifier.assert_node_counts({1, 0, 0, 0, 0});
  verifier.assert_growing_inodes({0, 0, 0, 0});
#endif  // UNODB_DETAIL_WITH_STATS

  verifier.insert(k1, unodb::test::test_values[2]);
  verifier.get_db().dump();  // FIXME REMOVE

  verifier.check_present_values();  // FIXME FAILS HERE
  verifier.check_absent_keys({k2});

#ifdef UNODB_DETAIL_WITH_STATS
  verifier.assert_node_counts({2, 1, 0, 0, 0});
  verifier.assert_growing_inodes({1, 0, 0, 0});
#endif  // UNODB_DETAIL_WITH_STATS
}
#endif

UNODB_END_TESTS()

}  // namespace
